# UnderstandingAndUsingCPointers

# Understanding And Using C Pointers

1. [Introduction]()
2. [Dynamic Memory Management in C]()
3. [Pointers and Functions]()
4. [Pointers and Arrays]()
5. [Pointers and Strings]()
6. [Pointers and Structures.]()
7. [Security Issues and the Improper Use of Pointers]()
8. [Odds and Ends]()


# Understanding And Using C Pointers

1. [Introduction]()
  - [Pointers and Memory ]()
     + [Why You Should Become Proficient with Pointers ]()
     + [Declaring Pointers ]()
     + [How to Read a Declaration ]()
     + [Address of Operator ]()
     + [Displaying Pointer Values ]()
     + [Dereferencing a Pointer Using the Indirection Operator ]()
     + [Pointers to Functions ]()
     + [The Concept of Null]()
  - [Pointer Size and Types ]()
     + [Memory Models ]()
     + [Predefined Pointer-Related Types ]()
  - [Pointer Operators ]()
     + [Pointer Arithmetic ]()
     + [Comparing Pointers]()
  - [Common Uses of Pointers ]()
     + [Multiple Levels of Indirection ]()
     + [Constants and Pointers]()
  - [Summary]()
2. [Dynamic Memory Management in C]()
  - [Dynamic Memory Allocation]()
     + [Memory Leaks]()
  - [Dynamic Memory Allocation Functions ]()
     + [Using the malloc Functions]()
     + [using the calloc Function]()
     + [Using the realloc Function]()
     + [The alloca Function and Variable Length Arrays ]()
  - [Deallocating Memory Using the free Function ]()
     + [Assigning NULL to a Freed Pointer ]()
     + [Double Free ]()
     + [The Heap and System Memory ]()
     + [Freeing Memory upon Program Termination ]()
  - [Dangling Pointers ]()
     + [Dangling Pointer Examples ]()
     + [Dealing with Dangling Pointers ]()
     + [Debug Version Support for Detecting Memory Leaks ]()
     + [Dynamic Memory Allocation Technologies ]()
     + [Garbage Collection in C ]()
     + [Resource Acquisition Is Initialization ]()
     + [Using Exception Handlers 56 Summary]()
3. [Pointers and Functions]()
  - [Program Stack and Heap ]()
     + [Program Stack ]()
     + [Organization of a Stack Frame]()
  - [Passing and Returning by Pointer ]()
     + [Passing Data Using a Pointer ]()
     + [Passing Data by Value ]()
     + [Passing a Pointer to a Constant ]()
     + [Returning a Pointer ]()
     + [Pointers to Local Data ]()
     + [Passing Null Pointers ]()
     + [Passing a Pointer to a Pointer]()
  - [Function Pointers ]()
     + [Declaring Function Pointers ]()
     + [Using a Function Pointer ]()
     + [Passing Function Pointers ]()
     + [Returning Function Pointers ]()
     + [Using an Array of Function Pointers]()
     + [Comparing Function Pointers ]()
     + [Casting Function Pointers]()
  - [Summary]()
4. [Pointers and Arrays]()
  - [Quick Review of Arrays ]()
     + [One-Dimensional Arrays]()
     + [Two-Dimensional Arrays]()
     + [Multidimensional Arrays ]()
  - [Pointer Notation and Arrays]()
     + [Differences Between Arrays and Pointers]()
  - [Using malloc to Create a One-Dimensional Array ]()
  - [Using the realloc Function to Resize an Array ]()
  - [Passing a One-Dimensional Array]()
     + [Using Array Notation]()
     + [Using Pointer Notation]()
  - [Using a One-Dimensional Array of Pointers ]()
  - [Pointers and Multidimensional Arrays]()
  - [Passing a Multidimensional Array]()
  - [Dynamically Allocating a Two-Dimensional Array]()
     + [Allocating Potentially Noncontiguous Memory]()
     + [Allocating Contiguous Memory ]()
  - [Jagged Arrays and Pointers Summary]()
5. [Pointers and Strings]()
  - [String Fundamentals ]()
     + [String Declaration ]()
     + [The String Literal Pool ]()
     + [String Initialization]()
  - [Standard String Operations ]()
     + [Comparing Strings ]()
     + [Copying Strings ]()
     + [Concatenating Strings]()
  - [Passing Strings]()
     + [Passing a Simple String]()
     + [Passing a Pointer to a Constant char ]()
     + [Passing a String to Be Initialized ]()
     + [Passing Arguments to an Application]()
  - [Returning Strings]()
     + [Returning the Address of a Literal]()
     + [Returning the Address of Dynamically Allocated Memory]()
  - [Function Pointers and Strings Summary]()
6. [Pointers and Structures.]()
  - [Introduction]()
     + [How Memory Is Allocated for a Structure]()
  - [Structure Deallocation Issues]()
  - [Avoiding malloc/free Overhead ]()
  - [Using Pointers to Support Data Structures ]()
     + [Single-Linked List ]()
     + [Using Pointers to Support a Queue ]()
     + [Using Pointers to Support a Stack ]()
     + [Using Pointers to Support a Tree ]()
  - [Summary 158]()
7. [Security Issues and the Improper Use of Pointers]()
  - [Pointer Declaration and Initialization ]()
     + [Improper Pointer Declaration ]()
     + [Failure to Initialize a Pointer Before It Is Used ]()
     + [Dealing with Uninitialized Pointers]()
  - [Pointer Usage Issues ]()
     + [Test for NULL ]()
     + [Misuse of the Dereference Operator ]()
     + [Dangling Pointers ]()
     + [Accessing Memory Outside the Bounds of an Array ]()
     + [Calculating the Array Size Incorrectly ]()
     + [Misusing the sizeof Operator ]()
     + [Always Match Pointer Types ]()
     + [Bounded Pointers ]()
     + [String Security Issues ]()
     + [Pointer Arithmetic and Structures ]()
     + [Function Pointer Issues]()
  - [Memory Deallocation Issues ]()
     + [Double Free ]()
     + [Clearing Sensitive Data]()
  - [Using Static Analysis Tools ]()
     + [Summary]()
8. [Odds and Ends]()
  - [Casting Pointers ]()
     + [Accessing a Special Purpose Address ]()
     + [Accessing a Port ]()
     + [Accessing Memory using DMA ]()
     + [Determining the Endianness of a Machine]()
  - [Aliasing, Strict Aliasing, and the restrict Keyword]()
     + [Using a Union to Represent a Value in Multiple Ways]()
     + [Strict Aliasing]()
     + [Using the restrict Keyword ]()
     + [Threads and Pointers]()
     + [Sharing Pointers Between Threads]()
     + [Using Function Pointers to Support Callbacks ]()
  - [Object-Oriented Techniques]()
     + [Creating and Using an Opaque Pointer]()
     + [Polymorphism in C Summary]()

# 1. [Introduction]()

A solid understanding of pointers and the ability to effectively use them separates a novice C programmer from a more experienced one. Pointers pervade the language and provide much of its flexibility. They provide important support for dynamic memory allocation, are closely tied to array notation, and when used to point to function, add another dimension to flow control in a program.

Pointers have long been a stumbling block in learning C. The basic concept of a pointer is simple: it is a variable that stores the address of a memory location. The concept however, quickly becomes complicated when we start applying pointer operators and try to discern their often cryptic notations. But this does not have to be the case. If we start simple and establish a firm foundation, then the advanced uses of pointers are not hard to follow and apply.

The key to comprehending pointers is understanding how memory is managed in a C program. After all, pointers contain addresses in memory. If we don't understand how memory is organized and managed, it is difficult to understand how pointers work. To address this concern, the organization of memory is illustrated whenever it is useful to explain a pointer concept. Once you have a firm grasp of memory and the ways it can be organized, understanding pointers becomes a lot easier.
#   - [Pointers and Memory ]()

When a C program is compiled, it works with three types of memory:

 - **Static/Global**

Statically declared variables are allocated to this type of memory. Global variables also use this region of memory. They are allocated when the program starts and remain in existence until the program terminates. While all functions have access to global variables, the scope of the static variables is restricted to their defining function.

 - **Automatic**

These variables are declared within a function and are created when a function is called. Their scope is restricted to the function, and their lifetime is limited to the time the function is executing.

- **Dynamic**
 
Memory is allocated from the heap and can be released as necessary. A pointer references the allocated memory. The scope is limited to the pointer of pointers that reference the memory. It exists until it is released. This is the focus of Chapter 2.

Table 1-1
| 				  | Scope																	    | Lifetime                       |
| --------- | ----------------------------------------- | -------------------------------|
| global		| The entire file														| The lifetime of the application|
| Static		| The function it is declared within				| The lifetime of the application|
| Automatic	| The function it is declared within				| While the function is executing|
| Dynamic		| Determined by the pointers that reference	| Until the memory is freed			 |

Understanding these types of memory will enable you to better understand how pointers work. Most pointers are used to manipulate data in memory. Understanding how memory is partitioned and organized will clarify how pointers manipulate memory.

A pointer variable contains the address of another variable, object, or function. An object is considered to be memory allocated using one of the memory allocation functions, such as the **malloc** function. A pointer is normally declared to be of a specific type depending on what it points to, such as a pointer to a char. The object may be any C data type such an integer, character, string, or structure. However, nothing inherent in a pointer indicates what type of data the pointer is referencing. A pointer only contains the address.

#      + [Why You Should Become Proficient with Pointers ]()
#      + [Declaring Pointers ]()
#      + [How to Read a Declaration ]()
#      + [Address of Operator ]()
#      + [Displaying Pointer Values ]()
#      + [Dereferencing a Pointer Using the Indirection Operator ]()
#      + [Pointers to Functions ]()
#      + [The Concept of Null]()
#   - [Pointer Size and Types ]()
#      + [Memory Models ]()
#      + [Predefined Pointer-Related Types ]()
#   - [Pointer Operators ]()
#      + [Pointer Arithmetic ]()
#      + [Comparing Pointers]()
#   - [Common Uses of Pointers ]()
#      + [Multiple Levels of Indirection ]()
#      + [Constants and Pointers]()
#   - [Summary]()
# 2. [Dynamic Memory Management in C]()
#   - [Dynamic Memory Allocation]()
#      + [Memory Leaks]()
#   - [Dynamic Memory Allocation Functions ]()
#      + [Using the malloc Functions]()
#      + [using the calloc Function]()
#      + [Using the realloc Function]()
#      + [The alloca Function and Variable Length Arrays ]()
#   - [Deallocating Memory Using the free Function ]()
#      + [Assigning NULL to a Freed Pointer ]()
#      + [Double Free ]()
#      + [The Heap and System Memory ]()
#      + [Freeing Memory upon Program Termination ]()
#   - [Dangling Pointers ]()
#      + [Dangling Pointer Examples ]()
#      + [Dealing with Dangling Pointers ]()
#      + [Debug Version Support for Detecting Memory Leaks ]()
#      + [Dynamic Memory Allocation Technologies ]()
#      + [Garbage Collection in C ]()
#      + [Resource Acquisition Is Initialization ]()
#      + [Using Exception Handlers 56 Summary]()
# 3. [Pointers and Functions]()
#   - [Program Stack and Heap ]()
#      + [Program Stack ]()
#      + [Organization of a Stack Frame]()
#   - [Passing and Returning by Pointer ]()
#      + [Passing Data Using a Pointer ]()
#      + [Passing Data by Value ]()
#      + [Passing a Pointer to a Constant ]()
#      + [Returning a Pointer ]()
#      + [Pointers to Local Data ]()
#      + [Passing Null Pointers ]()
#      + [Passing a Pointer to a Pointer]()
#   - [Function Pointers ]()
#      + [Declaring Function Pointers ]()
#      + [Using a Function Pointer ]()
#      + [Passing Function Pointers ]()
#      + [Returning Function Pointers ]()
#      + [Using an Array of Function Pointers]()
#      + [Comparing Function Pointers ]()
#      + [Casting Function Pointers]()
#   - [Summary]()
# 4. [Pointers and Arrays]()
#   - [Quick Review of Arrays ]()
#      + [One-Dimensional Arrays]()
#      + [Two-Dimensional Arrays]()
#      + [Multidimensional Arrays ]()
#   - [Pointer Notation and Arrays]()
#      + [Differences Between Arrays and Pointers]()
#   - [Using malloc to Create a One-Dimensional Array ]()
#   - [Using the realloc Function to Resize an Array ]()
#   - [Passing a One-Dimensional Array]()
#      + [Using Array Notation]()
#      + [Using Pointer Notation]()
#   - [Using a One-Dimensional Array of Pointers ]()
#   - [Pointers and Multidimensional Arrays]()
#   - [Passing a Multidimensional Array]()
#   - [Dynamically Allocating a Two-Dimensional Array]()
#      + [Allocating Potentially Noncontiguous Memory]()
#      + [Allocating Contiguous Memory ]()
#   - [Jagged Arrays and Pointers Summary]()
# 5. [Pointers and Strings]()
#   - [String Fundamentals ]()
#      + [String Declaration ]()
#      + [The String Literal Pool ]()
#      + [String Initialization]()
#   - [Standard String Operations ]()
#      + [Comparing Strings ]()
#      + [Copying Strings ]()
#      + [Concatenating Strings]()
#   - [Passing Strings]()
#      + [Passing a Simple String]()
#      + [Passing a Pointer to a Constant char ]()
#      + [Passing a String to Be Initialized ]()
#      + [Passing Arguments to an Application]()
#   - [Returning Strings]()
#      + [Returning the Address of a Literal]()
#      + [Returning the Address of Dynamically Allocated Memory]()
#   - [Function Pointers and Strings Summary]()
# 6. [Pointers and Structures.]()
#   - [Introduction]()
#      + [How Memory Is Allocated for a Structure]()
#   - [Structure Deallocation Issues]()
#   - [Avoiding malloc/free Overhead ]()
#   - [Using Pointers to Support Data Structures ]()
#      + [Single-Linked List ]()
#      + [Using Pointers to Support a Queue ]()
#      + [Using Pointers to Support a Stack ]()
#      + [Using Pointers to Support a Tree ]()
#   - [Summary 158]()
# 7. [Security Issues and the Improper Use of Pointers]()
#   - [Pointer Declaration and Initialization ]()
#      + [Improper Pointer Declaration ]()
#      + [Failure to Initialize a Pointer Before It Is Used ]()
#      + [Dealing with Uninitialized Pointers]()
#   - [Pointer Usage Issues ]()
#      + [Test for NULL ]()
#      + [Misuse of the Dereference Operator ]()
#      + [Dangling Pointers ]()
#      + [Accessing Memory Outside the Bounds of an Array ]()
#      + [Calculating the Array Size Incorrectly ]()
#      + [Misusing the sizeof Operator ]()
#      + [Always Match Pointer Types ]()
#      + [Bounded Pointers ]()
#      + [String Security Issues ]()
#      + [Pointer Arithmetic and Structures ]()
#      + [Function Pointer Issues]()
#   - [Memory Deallocation Issues ]()
#      + [Double Free ]()
#      + [Clearing Sensitive Data]()
#   - [Using Static Analysis Tools ]()
#      + [Summary]()
# 8. [Odds and Ends]()
#   - [Casting Pointers ]()
#      + [Accessing a Special Purpose Address ]()
#      + [Accessing a Port ]()
#      + [Accessing Memory using DMA ]()
#      + [Determining the Endianness of a Machine]()
#   - [Aliasing, Strict Aliasing, and the restrict Keyword]()
#      + [Using a Union to Represent a Value in Multiple Ways]()
#      + [Strict Aliasing]()
#      + [Using the restrict Keyword ]()
#      + [Threads and Pointers]()
#      + [Sharing Pointers Between Threads]()
#      + [Using Function Pointers to Support Callbacks ]()
#   - [Object-Oriented Techniques]()
#      + [Creating and Using an Opaque Pointer]()
#      + [Polymorphism in C Summary]()



